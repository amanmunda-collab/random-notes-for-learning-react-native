1. use Promise.all() to fetch transactions in parallel. 
2. use backticks if you want to use expressions inside the strings 
3. while writing objects in javascripts, if you want the  name and value have the same name write it like this 

--------------------------------------------------------------
 const signInAttempt = await signIn.create({
        identifier: emailAddress,
        password,
      });
--------------------------------------------------------------
4. ----------------------------------------------------------------
Debugging & Tooling
Remove console.log from Production: While great for development, console.log statements are synchronous and can seriously slow down the JavaScript thread in a bundled app.

Tip: Use a Babel plugin like babel-plugin-transform-remove-console to automatically strip them out of your production build.

Profile Your App: Use the React Native DevTools Profiler (available through the Developer Menu) to identify which components are rendering too often or taking too long. 
Seeing which components have orange/red bars will tell you exactly where to focus your memoization efforts.

Use the Performance Monitor: Enable the "Perf Monitor" in the Developer Menu to get real-time frames per second (FPS) for both the JS Thread (which runs your React code) and the UI Thread (which handles native UI and animations).
If your JS FPS drops below 60, you have a performance problem on the JavaScript side.

5. -------------------------------------------------------------------------------------
Pro Tip: Use the Platform module for clean, cross-platform code.

Instead of writing complex ternary operators or separate files for Android and iOS, 
use the built-in Platform module to manage small differences.
 like this ---> 
-------------------------------------------------------------------------------------------
import { Platform, StyleSheet } from 'react-native';

// 1. Specific Values
const shadowStyle = Platform.select({
  ios: {
    shadowColor: 'black',
    shadowOpacity: 0.2,
  },
  android: {
    elevation: 5, // Android's equivalent for shadow
  },
  default: {},
});

// 2. Specific Components (for larger differences)
const HeaderComponent = Platform.OS === 'ios' 
  ? MyIOSHeader 
  : MyAndroidHeader; 

// Usage
const MyScreen = () => (
  <>
    <HeaderComponent /> 
    <View style={shadowStyle} />
  </>
);

6. ----------------------------------------------------------------------------------------------------
Use InteractionManager.runAfterInteractions to delay heavy logic (network requests, heavy calculations) until the navigation animation finishes.


JavaScript

import { InteractionManager, useEffect, useState } from 'react-native';

const HeavyScreen = () => {
  const [isReady, setIsReady] = useState(false);

  useEffect(() => {
    // The task inside here won't run until the navigation animation is 100% done
    const task = InteractionManager.runAfterInteractions(() => {
      setIsReady(true);
      // Fire network requests here
    });

    return () => task.cancel();
  }, []);

  if (!isReady) return <LoadingPlaceholder />;

  return <ComplexComponent />;
};
Why it works: It explicitly prioritizes 60fps animations over data fetching.




